# Towards Answering "Am I on the Right Track?" Automatically using Program Synthesis, by Molly Q Feldman, Yiting Wang, William E. Byrd, François Guimbretière, Erik Andersen

This paper is not related to voice recognition or voice-based programming. I have included it here as related work because the proposed approach must deal with incomplete and/or incorrect input and compare this unreliable input with the expected input. With voice-based programming we must also handle incomplete/incorrect input and match it with valid (within a specific context) grammatical rules while accounting for probable identifiers, e.g., variables or functions that are in context. On the one hand, differently from the proposed intelligent tutoring system, we don't have a correct response that can be used to judge whether a solution is on the right track. On the other hand, recognition of a partial input may lead us to the wrong track (in terms of what the developer is actually trying to input) and we may have to assess whether the recognition is "on the right track" as more information becomes available.

The approach in this paper works with a very small subset of Scheme. It does not support loops, since Scheme has no loops. Maybe this simplifies the job of the program synthesis engine it leverages. I don't think the paper does a good job of explaining how holes are inserted. From what I could grasp, the implemented tool attempts to parse by applying the rules of the grammar. If it attempted to apply a rule but failed, the parts of the code that would be required for the rule to match are made into holes. For example, if the tool finds

```
if a ==
```

I assume that it first matches the rule for `if`, starts parsing the condition and matches the rule for expressions, predicate (because `==` is actually the prefix `equal?`), and, in this case, notices that something's missing for the `equal?` case and inserts a hole in that expression. It then backtracks to the `if` grammar rule, goes to the expression corresponding to the `if` body and notices that it is also missing, which results in another hole being inserted. It is not clear to me what the proposed approach does if an identifier is missing. Is there any sensible snippet to be synthesized in this case? Furthermore, I think dealing with ambiguity becomes easier in a language such as this subset of Scheme since it is very small and does not seem to create much ambiguity for a parser, e.g., if it starts with an `if`, there is only one possibility and operators are always prefixed.

The main problem that the evaluation of the proposed approach detected appears to be that the tool does not synthesize non-leaf nodes. The paper explains why this is not a good idea. However, this limitation led the tool to tell students that they were not on the right track when they actually were.