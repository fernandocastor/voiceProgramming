# Convo: What does conversational programming need? An exploration of machine learning interface design, anonymous

There is work on voice-based programming that is non-conversational. The paper cites a couple of these in refs [5] and [6]. The titles of both these papers mention "semantic parsing". It mentions the term "single-turn" program synthesis, where a natural language utterance is directly converted into a program without conversation. There is also syntax- or keyword-based voice programming, as discussed in refs [7] and [8]. Systems that work like that are "syntax- or keyword-dependent voice-based programming" systems. Andrew Begel's work fits into that category (ref. [7]).

One of the differentiating factors of this work is the *emphasis on conversational natural language interaction in a system to support multi-modal programming*, combining text-based (keyboard-based?) and voice-based interaction.  

This paper aims to assess factors such as the usability, feasibility, and cognitive load of a conversational system to support programming. The authors conducted a study where 45 participants used both voice and text (keyboard) to complete novice and advanced programming tasks while using a programming system named Convo developed by the authors. The results of the study where evaluated in terms of the opinions of the participants and also in terms of objective metrics such as time to complete the tasks, number of system resets, lengths of utterances, and number of times users asked for help. **Question**: were all the tasks successfully completed?

The authors believe that using some form of constrained natural language can reduce the potential for ambiguity, thus improving the precision of Convo. On the other hand, they raise the issue that such constraints can increase cognitive load by forcing the users to think about specific commands. The paper argues using refs [16] and [17] that using unconstrained natural language can create a great mismatch between what users expect and what the system is actually capable of understanding. This raises the question: **What exactly do the authors mean by "constrained"**? To what extent can NL be constrained so as to better support programming by voice? 

**Research topic**: Analyzing constrained vs. unconstrained natural language as a means to provide input for a voice-based programming system. Doing so in an objective, diverse manner is challenging. Going for opinions is easy. How to do that kind of study without having to build a system?

Most existing systems for voice-based programming are domain-specific. For example, there are systems supporting the construction of database queries and a Logo-like programming game.

Interesting comment: the paper mentions that auditory and visual information are processed through separate channels with limited capacity (ref. [33]). It then suggests that combining both channels as means to acquire information can reduce the cognitive load of programming activities. This is interesting, but I do not think it flies, in the same manner that it is hard to read while listening to music because, even though the information flows through different pipes, in the end, it does not feel like the brain deals with these pieces of information in parallel. 

Every participant of the study received a gift card. Overall, US$ 900!!!

Tests were performed both within subjects and between subjects. In the latter case, from what I could grasp, the participants were grouped as novice or advanced. 

In terms of time it took to perform the tasks of the study, text-based input outperformed voice-based input with statistical significance for all cases. Notwithstanding, the users considered voice-based input to be usable, efficient, and accessible. The paper did not report the accuracy of the results produced by the participants. Common themes identified by the authors include **improve speech-to-text** and **reduce NL constrains**. Not surprising, but it is nice to have hard evidence about this. 

This paper needs more information about the programming language that Convo employs. The paper makes it clear that it is not a conventional, off-the-shelf, text-based PL. What is it then? Which PL features does it support? Which notable features are not supported? Is it tailored for both voice-based and keyboard-based input modalities? How does the language cater to these two modalities? Furthermore, does voice-based input have a visual or textual representation or does the programmer have to maintain the entire program in their heads? In case it does have a textual or visual representation, is it different from what they would use with keyboard-based input?


## Hidehiko's opinion

This paper reports a user experiment that measures effectiveness of voice-based input for simple programs, and collects the participants opinions.  The subject system takes voice inputs, uses a speech recognition system to dictate utterances, match the text with several textual command patterns, and perform editor operations based on the matched commands.  The experiment let the participants to write simple programs (but uses a variable and conditional actions in a loop) by using the system.  It compares the voice-based input against text-based and voice-and-text-based input methods.  The paper reports the results of the experiment, and analyzes the opinions of the participants.

Since voice-recognition systems and natural language processing techniques are getting more powerful in these days, applying those techniques to programming  is a natural and timely idea.  As there are very many different possibilities of user-interface designs for such systems, attempts to assess the feasibility of one possible design would be useful.  In this sense, this paper is valuable to be published.

At the same time, the experiment has inevitable limitations.  Since the experiment has to use one particular system with a few number of programming tasks, the results, especially subjective opinions, can be affected by the design itself.  For example, the experiment can only answer to RQ1 (What is the preferred input modality?) from the participants preference with respect to the particular system design used in the experiment.  This is of course inevitable in this kind of research, but I would like to see more careful statements in the introduction so that readers cannot misunderstand.

I also wonder if the novice participants liked voice-based input over text-based input _for programming_, or they just liked voice over text for inputting any kind of text.  It is hard to guess from the descriptions in the paper, but if the novice (wrt programming) participants were not used to use keyboard for text inputting in general, it would be very reasonable they tend to prefer voice. 

I would like to know how the user check and edit program texts.  From the descriptions of the experiment results and analysis, it seems to be limited but not clear enough.  Please also discuss the effect of the code editing features on the participants' opinions.  When experienced programmers used a voice-input system with very limited editing features, and asked preference between voice-based and text-based modalities, they might prefer "text-based" by referring to their familiar modality, i.e., traditional programming editors.